# CHAdeMO
Communication between an EV and EVSE based on the CHAdeMO standard

The topic of the project I am working on during my internship at Typhoon HIL is Communication between an electric vehicle and a charger. The communication itself is implemented based on the CHAdeMO standard, which is based on the international standard IEC 61851-24, Annex A. CHAdeMO is Japanese fast charging standard, and it is used only for DC charging. Communication takes place via CAN (Controller Area Network) bus protocol which represents bidirectional serial communication protocol. CHAdeMO communication essentially comprises five CAN messages, where three of them are for the vehicle side and two for the charging station. Messages are implemented in the Typhoon HIL Control Center software. 
 
Both the charging station and the vehicle have got one CAN message each including the charge parameters and one CAN message for reporting errors (signaling errors, status) during charging process. Additionally, the vehicles got a CAN message that expresses the calculated charge time and the state of charge.

CAN messages don’t have an explicit address, instead, each message carries a numeric value ID (unique), which controls its priority on the bus and may also serve as an identification of the content of the message. Two standards are defined for CAAN bus message specification: CAN 2.0A – 11 bit identifier and CAN 2.0B – 29 bit identifier, and I used the first one. CAN bus messages are small, at most 8 data bytes. In Typhoon HIL, only HIL404, HIL604 and HIL606 devices can implement CAN communication. Each of these has two CAN controllers embedded that can physically accessed through standard 9 pin D-sub connector in the back of the HIL device. 
CAN Setup is used for configure the CAN controllers settings for the chosen HIL device. Exactly one CAN Setup component must exist in the model when we are using CAN protocol. We can specify the baud rate and the execution rate for each CAN controllers. CAN Send and  CAN Receive are similar: we can choose which CAN controller we will use, inside the window we are defining message ID, the message length and how it is going to be transmitted (on event or on timer). We can define our messages manually by clicking the add symbol, like I did, or instead of defining the messages manually, both CAN Send and CAN Receive components can import DBC files to define messages.
 
The loop itself, which is executing nonstop, is implemented in Advanced C Function block, the programming language which is used is C programming language, but this block also allows us to import files in C++ programming language (.cpp files), and also header files (.h files). Inputs in this component are actually received messages. And, those are messages that the charger delivered to the EV, but there are also some auxiliary variables. Outputs from this component are actually messages which EV is sending to the charger, and additionally, some variables which values I followed during simulation to check if everything is working properly.

The previously mentioned function that is executed every execution rate on the hil device is a function that is implemented in the Functions - Output function, and it is a function that calls the methods from the .cpp file so that they are executed. In addition to calling methods from the added file, there is also a check to see if we have received messages, as well as setting the parameters that should be sent.
 
In Initialization function, we can find initializations of some auxiliary variables, inputs and outputs, and there is a call of constructor CHADEMO(), which is also used for initialization of ordered variables. 
The logic of charging process of an electric vehicle is located in chademo.cpp file. There we are following and checking values of all parameters, both the received one, as well as the ones we are about to send, and based on that, states, that is, the relationship between electric vehicle and the charging station, are changing. For example: state WAIT_FOR_EVSE_PARAMS, state RUNNING – charging process, etc.
 
In electrical part of the project, we can see different contactors which are closed or opened via SCADA or through a specific input. On the upper right side is the battery that we charge, which actually simulates the battery found in an electric vehicle. This part of the project is based on standard IEC 61851-23. 
 
As part of the project, there is also the just mentioned HIL SCADA, through which I monitored the change in parameter values and the states the system goes through. These are mostly digital or text displays and entries, but there are also graphical displays of value changes as well as entries via sliders. The following image shows a view of the SCADA system. Of course, we can monitor any output here, and we can set most of the inputs here. Running can also be in the virtual mode (VHIL), and the real-time mode is on the real device HIL 404/604/606. 

If we are running in the real-time, model is executing on:
HIL 404 - the electrical part on the processor Zynq Ultrascale SoC, signal processing on 2xARM Cortex A53 64bit, 1333MHz 16MB external RAM per core.
HIL 604 - the electrical part on the processor Zynq-7 SoC, signal processing on ARM Cortex A9 32bit, 800MHz 256kB on-chip RAM 96MB external RAM.
HIL 606 - električni deo na procesoru Zynq Ultrascale SoC, signal processing on 2xARM Cortex A53 64bit, 1500MHz 16MB external RAM per core. 

How to use model?
When we open HIL SCADA, first of all, we need to close contactors SW (Charging cable) and after that close the contactor d1 which will set IN1 and when IN1 goes HIGH we have been plugged into the chademo port. Now we are in the state WAIT_FOR_EVSE_PARAMS, and because we don’t have EVSE side, we need to manually “receive” parameters from EVSE (increase by one receiveParams). Before that, send EV parameters to EVSE side. Now we are in the state WAIT_FOR_BEGIN_CONFIRMATION, so that means that we need to close d2 contactor, which will set IN2, then that will close contactors, and then we get into state RUNNING which means that we are charging our EV! Now we can monitor the battery charge, but we have to play the EVSE side and we need to receive parameters and status of EVSE every ~1min and less, until it’s full charged.
